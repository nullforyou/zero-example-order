// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"order/cmd/dao/model"
)

func newOrder(db *gorm.DB, opts ...gen.DOOption) order {
	_order := order{}

	_order.orderDo.UseDB(db, opts...)
	_order.orderDo.UseModel(&model.Order{})

	tableName := _order.orderDo.TableName()
	_order.ALL = field.NewAsterisk(tableName)
	_order.ID = field.NewInt64(tableName, "id")
	_order.OrderSerialNumber = field.NewString(tableName, "order_serial_number")
	_order.MemberID = field.NewInt64(tableName, "member_id")
	_order.Client = field.NewInt64(tableName, "client")
	_order.OrderStatus = field.NewInt64(tableName, "order_status")
	_order.OrderStatusName = field.NewString(tableName, "order_status_name")
	_order.OrderAmount = field.NewFloat64(tableName, "order_amount")
	_order.TechnicalServicesFee = field.NewFloat64(tableName, "technical_services_fee")
	_order.OrderExpressFee = field.NewFloat64(tableName, "order_express_fee")
	_order.GoodsNum = field.NewInt64(tableName, "goods_num")
	_order.OrderProfit = field.NewFloat64(tableName, "order_profit")
	_order.MemberNickname = field.NewString(tableName, "member_nickname")
	_order.MemberMobile = field.NewString(tableName, "member_mobile")
	_order.PaymentAmount = field.NewFloat64(tableName, "payment_amount")
	_order.PaymentSn = field.NewString(tableName, "payment_sn")
	_order.PaymentType = field.NewInt64(tableName, "payment_type")
	_order.PaymentTime = field.NewTime(tableName, "payment_time")
	_order.PaymentStatus = field.NewInt64(tableName, "payment_status")
	_order.DeductCoin = field.NewFloat64(tableName, "deduct_coin")
	_order.ReturnCredits = field.NewFloat64(tableName, "return_credits")
	_order.ReturnCreditsStatus = field.NewInt64(tableName, "return_credits_status")
	_order.ReturnCreditsFailedCause = field.NewString(tableName, "return_credits_failed_cause")
	_order.IsAppendPrice = field.NewInt64(tableName, "is_append_price")
	_order.AppendPriceStatus = field.NewInt64(tableName, "append_price_status")
	_order.IsAfterSales = field.NewInt64(tableName, "is_after_sales")
	_order.CancelOperator = field.NewInt64(tableName, "cancel_operator")
	_order.CancelTime = field.NewTime(tableName, "cancel_time")
	_order.CancelCause = field.NewString(tableName, "cancel_cause")
	_order.IsUserDelete = field.NewInt64(tableName, "is_user_delete")
	_order.UserDeleteTime = field.NewTime(tableName, "user_delete_time")
	_order.PaymentLimitTime = field.NewTime(tableName, "payment_limit_time")
	_order.SettleTime = field.NewTime(tableName, "settle_time")
	_order.CompleteTime = field.NewTime(tableName, "complete_time")
	_order.InvoiceStatus = field.NewInt64(tableName, "invoice_status")
	_order.AdminRemark = field.NewString(tableName, "admin_remark")
	_order.DeletedAt = field.NewField(tableName, "deleted_at")
	_order.CreatedAt = field.NewTime(tableName, "created_at")
	_order.UpdatedAt = field.NewTime(tableName, "updated_at")
	_order.IsDeductCoin = field.NewInt64(tableName, "is_deduct_coin")
	_order.DeductBalance = field.NewFloat64(tableName, "deduct_balance")
	_order.DeductType = field.NewInt64(tableName, "deduct_type")

	_order.fillFieldMap()

	return _order
}

type order struct {
	orderDo orderDo

	ALL                      field.Asterisk
	ID                       field.Int64
	OrderSerialNumber        field.String  // 销巴订单号
	MemberID                 field.Int64   // 用户id
	Client                   field.Int64   // 下单源 10：APP安卓；11：APPIOS; 12：WAP；13：小程序；20：PC
	OrderStatus              field.Int64   // 订单状态 -30:支付异常;-10:取消订单;10:新订单待支付;20:已支付;40:已完成待结算;50:已结算;
	OrderStatusName          field.String  // 订单状态名称(不需要手动赋值)
	OrderAmount              field.Float64 // 订单总金额（生成订单时的总价）
	TechnicalServicesFee     field.Float64 // 技术服务费,order_amount字段会加上技术服务费
	OrderExpressFee          field.Float64 // 运费
	GoodsNum                 field.Int64   // 商品总数量(不需要手动赋值)
	OrderProfit              field.Float64 // 订单利润
	MemberNickname           field.String  // 会员昵称
	MemberMobile             field.String  // 会员手机号
	PaymentAmount            field.Float64 // 应该支付总金额（生成订单时免去一切优惠券、积分抵扣、微币抵扣后需要支付的价格）
	PaymentSn                field.String  // 支付订单号（调用支付服务创建支付时返回）
	PaymentType              field.Int64   // 支付方式： 1：银联支付 2：支付宝支付 3：微信支付 4.个人余额 5.小巴余额
	PaymentTime              field.Time    // 支付时间
	PaymentStatus            field.Int64   // 订单支付状态0:未支付;1:已支付等待支付结果;2:支付成功;3:支付失败;
	DeductCoin               field.Float64 // 微币抵扣金额
	ReturnCredits            field.Float64 // 赠送积分（订单积分）
	ReturnCreditsStatus      field.Int64   // 赠送积分状态：-1:赠送失败；0：未赠送；1：已赠送;2:赠送中;
	ReturnCreditsFailedCause field.String  // 积分领取失败原因
	IsAppendPrice            field.Int64   // 是否补差价; 默认0=不需要; 1=需要
	AppendPriceStatus        field.Int64   // 补差价状态 0:未支付;1:已支付等待支付结果;2:支付成功;3:支付失败;
	IsAfterSales             field.Int64   // 介入退款流程 支付服务申请退款=1,支付服务退款完成=2,支付服务退款失败=3
	CancelOperator           field.Int64   // 取消操作：1 用户取消;2 系统取消(未付款自动取消)；3：平台管理取消；4：第三方取消；
	CancelTime               field.Time    // 取消时间，取消成功才有值(不需要手动赋值)
	CancelCause              field.String  // 取消原因（如果时自动取消也需要注明为超时自动取消）
	IsUserDelete             field.Int64   // 用户删除(0：未删除； 1：已删除)
	UserDeleteTime           field.Time    // 用户删除时间，删除成功才有值(不需要手动赋值)
	PaymentLimitTime         field.Time    // 支付时限，一般下单后有15分钟支付时限 ，必须在此时间前发起支付出票，超过这个时间订单将自动取消
	SettleTime               field.Time    // 结算时间，结算成功才有值(不需要手动赋值)
	CompleteTime             field.Time    // 完成时间，完成才有值(不需要手动赋值)
	InvoiceStatus            field.Int64   // 发票状态 1：未开具 2：申请中 3：已开
	AdminRemark              field.String  // 备注（后台订单备注）
	DeletedAt                field.Field
	CreatedAt                field.Time
	UpdatedAt                field.Time
	IsDeductCoin             field.Int64   // 是否使用抵扣; 默认0=不使用; 1使用红包抵扣;2余额抵扣;
	DeductBalance            field.Float64 // 余额抵扣金额
	DeductType               field.Int64   // 抵扣类型:0-未抵扣 1-红包抵扣 2-个人余额抵扣 3-小巴余额

	fieldMap map[string]field.Expr
}

func (o order) Table(newTableName string) *order {
	o.orderDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o order) As(alias string) *order {
	o.orderDo.DO = *(o.orderDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *order) updateTableName(table string) *order {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewInt64(table, "id")
	o.OrderSerialNumber = field.NewString(table, "order_serial_number")
	o.MemberID = field.NewInt64(table, "member_id")
	o.Client = field.NewInt64(table, "client")
	o.OrderStatus = field.NewInt64(table, "order_status")
	o.OrderStatusName = field.NewString(table, "order_status_name")
	o.OrderAmount = field.NewFloat64(table, "order_amount")
	o.TechnicalServicesFee = field.NewFloat64(table, "technical_services_fee")
	o.OrderExpressFee = field.NewFloat64(table, "order_express_fee")
	o.GoodsNum = field.NewInt64(table, "goods_num")
	o.OrderProfit = field.NewFloat64(table, "order_profit")
	o.MemberNickname = field.NewString(table, "member_nickname")
	o.MemberMobile = field.NewString(table, "member_mobile")
	o.PaymentAmount = field.NewFloat64(table, "payment_amount")
	o.PaymentSn = field.NewString(table, "payment_sn")
	o.PaymentType = field.NewInt64(table, "payment_type")
	o.PaymentTime = field.NewTime(table, "payment_time")
	o.PaymentStatus = field.NewInt64(table, "payment_status")
	o.DeductCoin = field.NewFloat64(table, "deduct_coin")
	o.ReturnCredits = field.NewFloat64(table, "return_credits")
	o.ReturnCreditsStatus = field.NewInt64(table, "return_credits_status")
	o.ReturnCreditsFailedCause = field.NewString(table, "return_credits_failed_cause")
	o.IsAppendPrice = field.NewInt64(table, "is_append_price")
	o.AppendPriceStatus = field.NewInt64(table, "append_price_status")
	o.IsAfterSales = field.NewInt64(table, "is_after_sales")
	o.CancelOperator = field.NewInt64(table, "cancel_operator")
	o.CancelTime = field.NewTime(table, "cancel_time")
	o.CancelCause = field.NewString(table, "cancel_cause")
	o.IsUserDelete = field.NewInt64(table, "is_user_delete")
	o.UserDeleteTime = field.NewTime(table, "user_delete_time")
	o.PaymentLimitTime = field.NewTime(table, "payment_limit_time")
	o.SettleTime = field.NewTime(table, "settle_time")
	o.CompleteTime = field.NewTime(table, "complete_time")
	o.InvoiceStatus = field.NewInt64(table, "invoice_status")
	o.AdminRemark = field.NewString(table, "admin_remark")
	o.DeletedAt = field.NewField(table, "deleted_at")
	o.CreatedAt = field.NewTime(table, "created_at")
	o.UpdatedAt = field.NewTime(table, "updated_at")
	o.IsDeductCoin = field.NewInt64(table, "is_deduct_coin")
	o.DeductBalance = field.NewFloat64(table, "deduct_balance")
	o.DeductType = field.NewInt64(table, "deduct_type")

	o.fillFieldMap()

	return o
}

func (o *order) WithContext(ctx context.Context) IOrderDo { return o.orderDo.WithContext(ctx) }

func (o order) TableName() string { return o.orderDo.TableName() }

func (o order) Alias() string { return o.orderDo.Alias() }

func (o *order) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *order) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 41)
	o.fieldMap["id"] = o.ID
	o.fieldMap["order_serial_number"] = o.OrderSerialNumber
	o.fieldMap["member_id"] = o.MemberID
	o.fieldMap["client"] = o.Client
	o.fieldMap["order_status"] = o.OrderStatus
	o.fieldMap["order_status_name"] = o.OrderStatusName
	o.fieldMap["order_amount"] = o.OrderAmount
	o.fieldMap["technical_services_fee"] = o.TechnicalServicesFee
	o.fieldMap["order_express_fee"] = o.OrderExpressFee
	o.fieldMap["goods_num"] = o.GoodsNum
	o.fieldMap["order_profit"] = o.OrderProfit
	o.fieldMap["member_nickname"] = o.MemberNickname
	o.fieldMap["member_mobile"] = o.MemberMobile
	o.fieldMap["payment_amount"] = o.PaymentAmount
	o.fieldMap["payment_sn"] = o.PaymentSn
	o.fieldMap["payment_type"] = o.PaymentType
	o.fieldMap["payment_time"] = o.PaymentTime
	o.fieldMap["payment_status"] = o.PaymentStatus
	o.fieldMap["deduct_coin"] = o.DeductCoin
	o.fieldMap["return_credits"] = o.ReturnCredits
	o.fieldMap["return_credits_status"] = o.ReturnCreditsStatus
	o.fieldMap["return_credits_failed_cause"] = o.ReturnCreditsFailedCause
	o.fieldMap["is_append_price"] = o.IsAppendPrice
	o.fieldMap["append_price_status"] = o.AppendPriceStatus
	o.fieldMap["is_after_sales"] = o.IsAfterSales
	o.fieldMap["cancel_operator"] = o.CancelOperator
	o.fieldMap["cancel_time"] = o.CancelTime
	o.fieldMap["cancel_cause"] = o.CancelCause
	o.fieldMap["is_user_delete"] = o.IsUserDelete
	o.fieldMap["user_delete_time"] = o.UserDeleteTime
	o.fieldMap["payment_limit_time"] = o.PaymentLimitTime
	o.fieldMap["settle_time"] = o.SettleTime
	o.fieldMap["complete_time"] = o.CompleteTime
	o.fieldMap["invoice_status"] = o.InvoiceStatus
	o.fieldMap["admin_remark"] = o.AdminRemark
	o.fieldMap["deleted_at"] = o.DeletedAt
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
	o.fieldMap["is_deduct_coin"] = o.IsDeductCoin
	o.fieldMap["deduct_balance"] = o.DeductBalance
	o.fieldMap["deduct_type"] = o.DeductType
}

func (o order) clone(db *gorm.DB) order {
	o.orderDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o order) replaceDB(db *gorm.DB) order {
	o.orderDo.ReplaceDB(db)
	return o
}

type orderDo struct{ gen.DO }

type IOrderDo interface {
	gen.SubQuery
	Debug() IOrderDo
	WithContext(ctx context.Context) IOrderDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOrderDo
	WriteDB() IOrderDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOrderDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOrderDo
	Not(conds ...gen.Condition) IOrderDo
	Or(conds ...gen.Condition) IOrderDo
	Select(conds ...field.Expr) IOrderDo
	Where(conds ...gen.Condition) IOrderDo
	Order(conds ...field.Expr) IOrderDo
	Distinct(cols ...field.Expr) IOrderDo
	Omit(cols ...field.Expr) IOrderDo
	Join(table schema.Tabler, on ...field.Expr) IOrderDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOrderDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOrderDo
	Group(cols ...field.Expr) IOrderDo
	Having(conds ...gen.Condition) IOrderDo
	Limit(limit int) IOrderDo
	Offset(offset int) IOrderDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOrderDo
	Unscoped() IOrderDo
	Create(values ...*model.Order) error
	CreateInBatches(values []*model.Order, batchSize int) error
	Save(values ...*model.Order) error
	First() (*model.Order, error)
	Take() (*model.Order, error)
	Last() (*model.Order, error)
	Find() ([]*model.Order, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Order, err error)
	FindInBatches(result *[]*model.Order, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Order) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOrderDo
	Assign(attrs ...field.AssignExpr) IOrderDo
	Joins(fields ...field.RelationField) IOrderDo
	Preload(fields ...field.RelationField) IOrderDo
	FirstOrInit() (*model.Order, error)
	FirstOrCreate() (*model.Order, error)
	FindByPage(offset int, limit int) (result []*model.Order, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOrderDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o orderDo) Debug() IOrderDo {
	return o.withDO(o.DO.Debug())
}

func (o orderDo) WithContext(ctx context.Context) IOrderDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o orderDo) ReadDB() IOrderDo {
	return o.Clauses(dbresolver.Read)
}

func (o orderDo) WriteDB() IOrderDo {
	return o.Clauses(dbresolver.Write)
}

func (o orderDo) Session(config *gorm.Session) IOrderDo {
	return o.withDO(o.DO.Session(config))
}

func (o orderDo) Clauses(conds ...clause.Expression) IOrderDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o orderDo) Returning(value interface{}, columns ...string) IOrderDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o orderDo) Not(conds ...gen.Condition) IOrderDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o orderDo) Or(conds ...gen.Condition) IOrderDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o orderDo) Select(conds ...field.Expr) IOrderDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o orderDo) Where(conds ...gen.Condition) IOrderDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o orderDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IOrderDo {
	return o.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (o orderDo) Order(conds ...field.Expr) IOrderDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o orderDo) Distinct(cols ...field.Expr) IOrderDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o orderDo) Omit(cols ...field.Expr) IOrderDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o orderDo) Join(table schema.Tabler, on ...field.Expr) IOrderDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o orderDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOrderDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o orderDo) RightJoin(table schema.Tabler, on ...field.Expr) IOrderDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o orderDo) Group(cols ...field.Expr) IOrderDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o orderDo) Having(conds ...gen.Condition) IOrderDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o orderDo) Limit(limit int) IOrderDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o orderDo) Offset(offset int) IOrderDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o orderDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOrderDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o orderDo) Unscoped() IOrderDo {
	return o.withDO(o.DO.Unscoped())
}

func (o orderDo) Create(values ...*model.Order) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o orderDo) CreateInBatches(values []*model.Order, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o orderDo) Save(values ...*model.Order) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o orderDo) First() (*model.Order, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Order), nil
	}
}

func (o orderDo) Take() (*model.Order, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Order), nil
	}
}

func (o orderDo) Last() (*model.Order, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Order), nil
	}
}

func (o orderDo) Find() ([]*model.Order, error) {
	result, err := o.DO.Find()
	return result.([]*model.Order), err
}

func (o orderDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Order, err error) {
	buf := make([]*model.Order, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o orderDo) FindInBatches(result *[]*model.Order, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o orderDo) Attrs(attrs ...field.AssignExpr) IOrderDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o orderDo) Assign(attrs ...field.AssignExpr) IOrderDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o orderDo) Joins(fields ...field.RelationField) IOrderDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o orderDo) Preload(fields ...field.RelationField) IOrderDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o orderDo) FirstOrInit() (*model.Order, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Order), nil
	}
}

func (o orderDo) FirstOrCreate() (*model.Order, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Order), nil
	}
}

func (o orderDo) FindByPage(offset int, limit int) (result []*model.Order, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o orderDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o orderDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o orderDo) Delete(models ...*model.Order) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *orderDo) withDO(do gen.Dao) *orderDo {
	o.DO = *do.(*gen.DO)
	return o
}
